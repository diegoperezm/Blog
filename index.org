#+TITLE: BLOG

* 500 lines or less, AOSA
:PROPERTIES:
:CUSTOM_ID: 500-lines-or-less 
:END: 
 
 This book is something that I was looking for some time.The idea is simple: "provide unique insights into how [programmers] think".

 The URL to get the book: [[https://aosabook.org/en/][The Architecture of Open Source Applications]]


** Blockcode: A visual programming toolkit, Dethe Elza

*** Highlights

- Procedural code

#+BEGIN_QUOTE
The code style is procedural, not object-oriented or functional. We could do the same things in any of these paradigms, but that would require more setup code and wrappers to impose on what exists already for the DOM.
#+END_QUOTE


- Single file for random functions

#+BEGIN_QUOTE
Having a single file to gather random functions in is useful, especially when an architecture is under development. My theory of keeping a clean house is to have designated places for clutter, and that applies to building a program architecture too. As this file grows it is important to watch for emerging patterns: several related functions can be spun off into a separate module (or joined together into a more general function). You don't want the catch-all to grow indefinitely, but only to be a temporary holding place until you figure out the right way to organize the code.
#+END_QUOTE


- Why No use MVC
  
#+BEGIN_QUOTE
...it isn't the right tool for every problem. All the state (the "model" in MVC) is captured by the block elements in a block language anyway, so replicating it into Javascript has little benefit unless there is some other need for the model (if we were editing shared, distributed code, for instance).
... An early version of Waterbear went to great lengths to keep the model in JavaScript and sync it with the DOM, until I noticed that more than half the code and 90% of the bugs were due to keeping the model in sync with the DOM.
#+END_QUOTE


* Problem Solving: Bottom-up approach
:PROPERTIES:
:CUSTOM_ID: Problem-Solving-Bottom-up-approach
:END: 
 
** Bottom-up  approach  

   - In a bottom-up approach the problem analysis  starts at the lowest level possible

   - Individual parts of the system are implemented

   - This parts are then linked to form larger components 

   - This process continues till all system components are implemented.


***  Bottom-up approach common patterns 

  When using the bottom-up approach, there are some patterns that we can identify:

- Most of the programs follows the  event-action paradigm[0]: 

  - Users supplies an event and

  - A sequence of actions is executed in response to that event
    
- Event-handlers will  execute functions in response to an event 

- Elements of the user interface may respond to an event in different ways, depending on the context

- if-else statements are used to determine the context and which functions are executed 

- Event-handlers must use information shared between user interface objects

- To share information the following  options are used: 

  - Explicit global variables

  - A value contained in an user interface object 

  - Other attribute of an object


*** Calculator example (Bottom-up)

#+BEGIN_SRC js
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      currentVal: "0",
      prevVal: "0",
      formula: "",
      currentSign: "pos",
      lastClicked: ""
    };
    // ....
  }

  initialize() {
    this.setState({
      currentVal: "0",
      prevVal: "0",
      formula: "",
      currentSign: "pos",
      lastClicked: "",
      evaluated: false
    });
  }

  handleDecimal() {
    if (this.state.evaluated === true) {
     // ... 
    } else if (
      !this.state.currentVal.includes(".") &&
      !this.state.currentVal.includes("Limit")
    ) {
     // ...
      if (this.state.currentVal.length > 21) {
     // ...
      } else if (
        endsWithOperator.test(this.state.formula) ||
        (this.state.currentVal === "0" && this.state.formula === "")
      ) {
      // ...
      } else {
      // ...
      }
    }
   }
    
  handleEvaluate() {
    if (!this.state.currentVal.includes("Limit")) {
    //   ...
        expression = expression.replace(/x/g, "*").replace(/‑/g, "-");

     while (endsWithOperator.test(expression)) {
        expression = expression.slice(0, -1);
      }
    // ...
    }
  }

  handleOperators(e) {
    if (!this.state.currentVal.includes("Limit")) {
      // ...
      if (evaluated) {
      // ...
      } else if (!endsWithOperator.test(formula)) {
      // ...
      } else if (!endsWithNegativeSign.test(formula)) {
      // ...
      } else if (value !== "‑") {
      // ...
      }
    }
  }

  handleNumbers(e) {
    if (!this.state.currentVal.includes("Limit")) {
     // ...
      if (currentVal.length > 21) {
     // ... 
      } else if (evaluated) {
     // ...
      } else {
     // ...
    }
   }
  }

}
#+END_SRC


** References

[0] https://en.wikipedia.org/wiki/Event-driven_programming

#+BEGIN_QUOTE
 In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks). 
#+END_QUOTE

[1] https://en.wikipedia.org/wiki/Event-driven_programming#Criticism

#+BEGIN_QUOTE
 The design of those programs which rely on event-action model has been criticised, and it has been suggested that the event-action model leads programmers to create error-prone, difficult to extend and excessively complex application code. Table-driven state machines have been advocated as a viable alternative. On the other hand, table-driven state machines themselves suffer from significant weaknesses including state explosion phenomena. A solution for this is to use Petri nets. 
#+END_QUOTE


[2] Constructing the User Interface with Statecharts, Ian Horrocks, 1999.  ISBN-10: 0201342782


* Tracking Fatigue: Tapping Rate Test
:PROPERTIES:
:CUSTOM_ID: Tracking-Fatigue-Tapping-Rate-Test
:END: 
 
 As far as I could find when the topic of burnout/fatigue is discussed the recommendation is the use of pomodoros and take multiple  breaks (and days off).

 Pomodoros and breaks are really good, but doesn't take to account that: 


- Not all tasks require the same amount of effort:\\
  For example, there are tasks that require multiple decisions and others that are mostly mechanical.


- Coding is not a pure mental task:\\
   Sitting for extend period of time can produce health and other problems (back pain, spinal compression, etc.)


 
  Therefore, it is  necessary to use a method that can give more  information than the lack of focus. A method that can be used is the "Tapping Rate Test".

** Description

[[https://en.wikipedia.org/wiki/Tapping_rate][Wikipedia, Tapping rate:]]

#+BEGIN_QUOTE
  The tapping rate is a psychological test given to assess the integrity of the neuromuscular system and examine motor control.
#+END_QUOTE

#+BEGIN_QUOTE
 The finger tapping test has the advantage of being a relatively pure neurologically driven motor task because the inertial and intersegmental interactions are so small that biomechanical influences on movement are reduced.
#+END_QUOTE


#+BEGIN_QUOTE
  Finger tapping involves three important features: time, spatial amplitude, and frequency. Studies have reported that the average number of taps per 10-second interval can be used to distinguish between patients with mild traumatic brain injury and healthy controls, is slower in people one month after sustaining a mild traumatic brain injury, and in experienced boxers and soccer players who frequently "headed" the ball the speed of finger tapping has also been found to be related to severity of initial traumatic brain injury, and can be used to help assess recovery from mild and moderate traumatic brain injuries
#+END_QUOTE


[[https://link.springer.com/referenceworkentry/10.1007%252F978-1-4419-1698-3_343][Springer, Finger-Tapping Test:]]

#+BEGIN_QUOTE
 During administration, **the subject's palm should be immobile and flat on the board, with fingers extended, and the index finger placed on the counting device.**
#+END_QUOTE


#+BEGIN_QUOTE
 One hand at a time, **subjects tap their index finger on the lever as quickly as possible within a 10-s time interval,** in order to increase the number on the counting device with each tap. The original procedure calls for five consecutive trials within a 5-point range for each hand, but variations include a total of six trials, in two sets of three. 
#+END_QUOTE


** How I am doing it


- Test in the morning (wake up->no coffee->test)


- I am only doing it  one time , 10 seconds


- I am trying to identify task effort (heavy vs light)

  

 That's all, I hope it can be useful to someone.



